// Copyright 2023-2024 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0

#include "ArrasSettings.h"

#include <hydramoonray/RenderSettings.h>
#include <hydramoonray/Utils.h>

#include <scene_rdl2/render/logging/logging.h>
#include <sdk/sdk.h>

#include <pxr/base/vt/value.h>

#include <fstream>
#include <vector>

using namespace pxr;

namespace {

TF_DEFINE_PRIVATE_TOKENS(Tokens,
   (useRemoteHosts)
   (remoteHosts)
   (localReservedCores)
   (logLevel)
   (maxFps)
   (maxConnectRetries)
   (enableDenoise)
   (enableOIDN)
   (denoiseAlbedoGuiding)
   (denoiseNormalGuiding)
);

using scene_rdl2::logging::Logger;
using namespace hdMoonray;

std::string getMoonPackage()
{
    // tries to identify the right version of either moonray or
    // moonshine to include in the computation rez environment
    // if client env contains moonshine, use the same version
    const char* rezMoonshine = getEnv("REZ_MOONSHINE_VERSION","");
    if (*rezMoonshine) {
	return std::string("moonshine-") + rezMoonshine;
    }
    // if client env contains moonbase_proxies, use a matched version
    // of moonshine
    const char* rezMoonbase = getEnv("REZ_MOONBASE_PROXIES_VERSION","");
    if (*rezMoonbase) {
	return std::string("moonshine-") + rezMoonbase;
    }
    // if client env contains moonray, use a matched version of
    // moonray
    const char* rezMoonray = getEnv("REZ_MOONRAY_VERSION","");
    if (*rezMoonray) {
	return std::string("moonray-") + rezMoonray;
    }
    return std::string();
}

const std::string& getRezRxt()
{
    // return the contents of the resolved context (RXT) file generated by REZ
    // for the client environment. Returns "" if contents cannot be obtained.
    static std::string rxt("UNINIT");
    if (rxt == "UNINIT") {
        rxt.clear();
        const char* rxtfile = getEnv("REZ_RXT_FILE","");
        if (!*rxtfile) return rxt;
        std::ifstream ifs(rxtfile, std::ios::in | std::ios::binary | std::ios::ate);
        if (ifs.fail()) {
            Logger::warn("Cannot open REZ RXT file: "+std::string(rxtfile));
            return rxt;
        }
        std::ifstream::pos_type fileSize = ifs.tellg();
        ifs.seekg(0, std::ios::beg);
        std::vector<char> bytes(fileSize);
        ifs.read(bytes.data(), fileSize);
        if (ifs.fail()) {
            Logger::warn("Cannot read REZ RXT file: "+std::string(rxtfile));
            return rxt;
        }
        rxt = std::string(bytes.data(),fileSize);
    }
    return rxt;
}

void setRequirement(arras4::client::SessionDefinition& def,
		    const std::string& key, const std::string& val)
{
    // set a requirement on all mcrt computations
    // (will be simpler using named contexts, but this is not fully deployed yet)
    if (def.has("mcrt")) def["mcrt"]["requirements"][key] = val;
    if (def.has("merge")) def["merge"]["requirements"][key] = val;
    if (def.has("dispatch")) def["dispatch"]["requirements"][key] = val;
}

void setupPackaging(bool local,
                    arras4::client::SessionDefinition& def)
{
    // fill in REZ packaging parameters for the mcrt computations
    //
    // if we can reuse the client environment for the computations, we
    // can avoid the cost of a REZ resolve (which can be quite slow...)
    // -- need to check if our env contains the packages needed by
    //    the computation
    if (*getEnv("REZ_MCRT_COMPUTATION_VERSION","") &&
        *getEnv("REZ_ARRAS4_CORE_VERSION","") &&
        *getEnv("REZ_MOONRAY_VERSION","")) {
            // yes we can
            if (local) {
                // On the same machine, Arras can directly reuse the local environment
                Logger::info("Running computation in current environment");
                setRequirement(def,"packaging_system","current-environment");
                return;
            } else {
                // For a remote render, we have to send across the environment. This
                // is done by sending the REZ RXT file...
                const std::string& rxt = getRezRxt();
                if (!rxt.empty()) {
                    std::cout << "Using pre-resolved REZ environment" << std::endl;
                    Logger::info("Sending RXT environment to computation");
                    setRequirement(def,"packaging_system","rez2");
                    setRequirement(def,"rez_context",rxt);
                    return;
                }
            }
    }
    // otherwise we will have to perform a rez resolve in the computation when it starts up.
    // try to use the same version of moonray/moonshine that we have in our env
    std::string moonPackage = getMoonPackage();
    if (moonPackage.empty()) return; // fall back to whatever the def file specifies
    std::cout << "Performing remote REZ resolve" << std::endl;
    std::string allPackages = "mcrt_computation " + moonPackage + " arras4_core";
    Logger::info("Running computation with packages '",allPackages,"'");
    setRequirement(def,"packaging_system","rez2");
    setRequirement(def,"rez_packages",allPackages);
}

} // namespace {

namespace hdMoonray {

ArrasSettings::ArrasSettings()
{
    // may throw arras4::client::DefinitionLoadError
    mSingleHostTemplDef = arras4::client::SessionDefinition::load("hd_single");
    mMultiHostTemplDef =  arras4::client::SessionDefinition::load("hd_multi");
}

void
ArrasSettings::addDescriptors(HdRenderSettingDescriptorList& descriptorList) const
{
    static const int hosts = getEnv("HDMOONRAY_HOSTS", 0);
    static HdRenderSettingDescriptorList descriptors = {
        { "Use Remote Hosts",        Tokens->useRemoteHosts,       VtValue(hosts > 0) },
        { "Remote Hosts",            Tokens->remoteHosts,          VtValue(hosts > 0 ? hosts : 5) },
        { "Local Reserved Cores",    Tokens->localReservedCores,   VtValue(getEnv("HDMOONRAY_LOCAL_RESERVED_CORES",1))},
        { "Log Level(1-5)",          Tokens->logLevel,             VtValue(getEnv("HDMOONRAY_LOGLEVEL", 1)) },
        { "Max FPS",                 Tokens->maxFps,               VtValue(getEnv("HDMOONRAY_MAX_FPS", 12.0f)) },
        { "Maximum connect retries", Tokens->maxConnectRetries,    VtValue(getEnv("HDMOONRAY_MAX_CONNECT_RETRIES",2)) },
        { "Enable Denoising",        Tokens->enableDenoise,        VtValue(getEnv("HDMOONRAY_ENABLE_DENOISE",false)) },
        { "Enable OIDN",             Tokens->enableOIDN,           VtValue(getEnv("HDMOONRAY_ENABLE_DENOISE_OIDN",false)) },
        { "Denoise Albedo Guiding",  Tokens->denoiseAlbedoGuiding, VtValue(getEnv("HDMOONRAY_DENOISE_ALBEDO_GUIDING", false)) },
        { "Denoise Normal Guiding",  Tokens->denoiseNormalGuiding, VtValue(getEnv("HDMOONRAY_DENOISE_NORMAL_GUIDING", false)) }
    };
    for (const auto& desc : descriptors) {
        descriptorList.push_back(desc);
    }
}

std::string
ArrasSettings::getUrl(arras4::sdk::SDK& sdk)
{
    if (mLocalMode) {
        return "arras:local";
    }
    std::string stack(getEnv("HDMOONRAY_STACK", "prod"));
    std::string dc("gld");
    // $HDMOONRAY_STACK can be <env> (e.g. "prod") or <env>-<dc> (e.g. "stb-gld")
    // or url-<url>
    size_t p = stack.find('-');
    if (p != std::string::npos) {
        dc = stack.substr(p+1);
        stack = stack.substr(0,p);
    }
    if (stack == "url") {
        return dc + "/coordinator/1/sessions";
    }
    try {
        return sdk.requestArrasUrl(dc, stack);
    } catch (const arras4::sdk::SDKException& e) {
        Logger::error("Failed to get Arras url for '", stack, "': ", e.what());
        return {};
    }
}

arras4::client::SessionDefinition
ArrasSettings::getSessionDefinition()
{
    arras4::client::SessionDefinition def;
    if (!mLocalMode && mHostCount > 1) {
        def = mMultiHostTemplDef;
        if (def.has("mcrt")) def["mcrt"]["arrayExpand"] = mHostCount;
    } else {
        def = mSingleHostTemplDef;
        if (def.has("mcrt")) def["mcrt"]["requirements"]["resources"]["reservedCores"] = mLocalReservedCores;
    }
    setupPackaging(mLocalMode,def);
    if (def.has("mcrt")) {
        def["mcrt"]["fps"] = mMaxFps;
        def["mcrt"]["exec_mode"] = mExecMode;
    }
    if (def.has("merge")) def["merge"]["fps"] = mMaxFps;
    if (def.has("dispatch")) def["dispatch"]["fps"] = mMaxFps;
    return def;
}

arras4::client::SessionOptions
ArrasSettings::getSessionOptions()
{
    const char* v = getEnv("HDMOONRAY_PRODUCTION","");
    return arras4::client::SessionOptions().setProduction(v);
}

void
ArrasSettings::setLocalMode(bool flag)
{
    if (flag != mLocalMode) {
        mLocalMode = flag;
        mReconnectRequired = true;
    }
}

void
ArrasSettings::setLocalReservedCores(int val)
{
    if (val != mLocalReservedCores) {
        mLocalReservedCores = val;
        if (mLocalMode) mReconnectRequired = true;
    }
}

void
ArrasSettings::setHostCount(int count)
{
    if (count != mHostCount) {
        mHostCount = count;
        if (!mLocalMode) mReconnectRequired = true;
    }
}

void
ArrasSettings::setMaxFps(float val)
{
    if (val != mMaxFps) {
        mMaxFps = val;
        mReconnectRequired = true;
    }
}

void
ArrasSettings::setExecMode(std::string val)
{
    if (val != mExecMode){
        if (val == "vectorized" || val == "auto" || val == "xpu" || val == "scalar") {
            mExecMode = val;
            mReconnectRequired = true;
        }
    }
}

void
ArrasSettings::setDenoiseMode(bool enable, bool oidn, bool albedoGuiding, bool normalGuiding)
{
    if (!enable && !oidn) {
        mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::DISABLE;
    } else if (albedoGuiding) {
        if (normalGuiding) {
            mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE_W_ALBEDO_NORMAL;
        } else {
            mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE_W_ALBEDO;
        }
    } else if (normalGuiding) {
        mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE_W_NORMAL;
    } else {
        mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE;
    }
}

void
ArrasSettings::setDenoiseEngine(bool enable, bool oidn)
{
    if (enable){
        if (oidn) {
            mDenoiseEngine = mcrt_dataio::ClientReceiverFb::DenoiseEngine::OPEN_IMAGE_DENOISE;
        } else {
            mDenoiseEngine = mcrt_dataio::ClientReceiverFb::DenoiseEngine::OPTIX;
        }
    }
}

void
ArrasSettings::applySettings(const RenderSettings& settings)
{
    setLocalMode(!settings.get<bool>(Tokens->useRemoteHosts));
    setLogLevel(settings.get<int>(Tokens->logLevel));
    setHostCount(settings.get<int>(Tokens->remoteHosts));
    setLocalReservedCores(settings.get<int>(Tokens->localReservedCores));
    setMaxFps(settings.get<float>(Tokens->maxFps));
    setExecMode(settings.getExecutionMode());
    setMaxConnectRetries(settings.get<int>(Tokens->maxConnectRetries));
    setDenoiseMode(settings.get<bool>(Tokens->enableDenoise),
                   settings.get<bool>(Tokens->enableOIDN),
                   settings.get<bool>(Tokens->denoiseAlbedoGuiding),
                   settings.get<bool>(Tokens->denoiseNormalGuiding));
}

}
