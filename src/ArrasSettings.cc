// Copyright 2023-2024 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0

#include "ArrasSettings.h"
#include "RenderSettings.h"

#include <scene_rdl2/render/logging/logging.h>
#include <sdk/sdk.h>

#include <fstream>
#include <vector>

namespace {

using scene_rdl2::logging::Logger;
using hdMoonray::RenderSettings;

std::string getMoonPackage()
{
    // tries to identify the right version of either moonray or
    // moonshine to include in the computation rez environment
    // if client env contains moonshine, use the same version
    const char* rezMoonshine = RenderSettings::getenvString("REZ_MOONSHINE_VERSION");
    if (*rezMoonshine) {
	return std::string("moonshine-") + rezMoonshine;
    }
    // if client env contains moonbase_proxies, use a matched version
    // of moonshine
    const char* rezMoonbase = RenderSettings::getenvString("REZ_MOONBASE_PROXIES_VERSION");
    if (*rezMoonbase) {
	return std::string("moonshine-") + rezMoonbase;
    }
    // if client env contains moonray, use a matched version of
    // moonray
    const char* rezMoonray = RenderSettings::getenvString("REZ_MOONRAY_VERSION");
    if (*rezMoonray) {
	return std::string("moonray-") + rezMoonray;
    }
    return std::string();
}

const std::string& getRezRxt()
{
    // return the contents of the resolved context (RXT) file generated by REZ
    // for the client environment. Returns "" if contents cannot be obtained.
    static std::string rxt("UNINIT");
    if (rxt == "UNINIT") {
        rxt.clear();
        const char* rxtfile = RenderSettings::getenvString("REZ_RXT_FILE");
        if (!*rxtfile) return rxt;
        std::ifstream ifs(rxtfile, std::ios::in | std::ios::binary | std::ios::ate);
        if (ifs.fail()) {
            Logger::warn("Cannot open REZ RXT file: "+std::string(rxtfile));
            return rxt;
        }
        std::ifstream::pos_type fileSize = ifs.tellg();
        ifs.seekg(0, std::ios::beg);
        std::vector<char> bytes(fileSize);
        ifs.read(bytes.data(), fileSize);
        if (ifs.fail()) {
            Logger::warn("Cannot read REZ RXT file: "+std::string(rxtfile));
            return rxt;
        }
        rxt = std::string(bytes.data(),fileSize);
    }
    return rxt;
}

void setRequirement(arras4::client::SessionDefinition& def,
		    const std::string& key, const std::string& val)
{
    // set a requirement on all mcrt computations
    // (will be simpler using named contexts, but this is not fully deployed yet)
    if (def.has("mcrt")) def["mcrt"]["requirements"][key] = val;
    if (def.has("merge")) def["merge"]["requirements"][key] = val;
    if (def.has("dispatch")) def["dispatch"]["requirements"][key] = val;
}

void setupPackaging(bool local,
                    arras4::client::SessionDefinition& def)
{
    // fill in REZ packaging parameters for the mcrt computations
    //
    // if we can reuse the client environment for the computations, we
    // can avoid the cost of a REZ resolve (which can be quite slow...)
    // -- need to check if our env contains the packages needed by
    //    the computation
    if (*RenderSettings::getenvString("REZ_MCRT_COMPUTATION_VERSION") &&
        *RenderSettings::getenvString("REZ_ARRAS4_CORE_VERSION") &&
        *RenderSettings::getenvString("REZ_MOONRAY_VERSION")) {
            // yes we can
            if (local) {
                // On the same machine, Arras can directly reuse the local environment
                Logger::info("Running computation in current environment");
                setRequirement(def,"packaging_system","current-environment");
                return;
            } else {
                // For a remote render, we have to send across the environment. This
                // is done by sending the REZ RXT file...
                const std::string& rxt = getRezRxt();
                if (!rxt.empty()) {
                    std::cout << "Using pre-resolved REZ environment" << std::endl;
                    Logger::info("Sending RXT environment to computation");
                    setRequirement(def,"packaging_system","rez2");
                    setRequirement(def,"rez_context",rxt);
                    return;
                }
            }
    }
    // otherwise we will have to perform a rez resolve in the computation when it starts up.
    // try to use the same version of moonray/moonshine that we have in our env
    std::string moonPackage = getMoonPackage();
    if (moonPackage.empty()) return; // fall back to whatever the def file specifies
    std::cout << "Performing remote REZ resolve" << std::endl;
    std::string allPackages = "mcrt_computation " + moonPackage + " arras4_core";
    Logger::info("Running computation with packages '",allPackages,"'");
    setRequirement(def,"packaging_system","rez2");
    setRequirement(def,"rez_packages",allPackages);
}

} // namespace {

namespace hdMoonray {

ArrasSettings::ArrasSettings()
{
    // may throw arras4::client::DefinitionLoadError
    mSingleHostTemplDef = arras4::client::SessionDefinition::load("hd_single");
    mMultiHostTemplDef =  arras4::client::SessionDefinition::load("hd_multi");
}

arras4::log::Logger::Level
ArrasSettings::getLogLevel()
{
    return static_cast<arras4::log::Logger::Level>(mLogLevel);
}

std::string
ArrasSettings::getUrl(arras4::sdk::SDK& sdk)
{
    if (mLocalMode) {
        return "arras:local";
    }
    std::string stack(RenderSettings::getenvString("HDMOONRAY_STACK", "prod"));
    std::string dc("gld");
    // $HDMOONRAY_STACK can be <env> (e.g. "prod") or <env>-<dc> (e.g. "stb-gld")
    // or url-<url>
    size_t p = stack.find('-');
    if (p != std::string::npos) {
        dc = stack.substr(p+1);
        stack = stack.substr(0,p);
    }
    if (stack == "url") {
        return dc + "/coordinator/1/sessions";
    }
    try {
        return sdk.requestArrasUrl(dc, stack);
    } catch (const arras4::sdk::SDKException& e) {
        Logger::error("Failed to get Arras url for '", stack, "': ", e.what());
        return {};
    }
}

arras4::client::SessionDefinition
ArrasSettings::getSessionDefinition()
{
    arras4::client::SessionDefinition def;
    if (!mLocalMode && mHostCount > 1) {
        def = mMultiHostTemplDef;
        if (def.has("mcrt")) def["mcrt"]["arrayExpand"] = mHostCount;
    } else {
        def = mSingleHostTemplDef;
        if (def.has("mcrt")) def["mcrt"]["requirements"]["resources"]["reservedCores"] = mLocalReservedCores;
    }
    setupPackaging(mLocalMode,def);
    if (def.has("mcrt")) {
        def["mcrt"]["fps"] = mMaxFps;
        def["mcrt"]["exec_mode"] = mExecMode;
    }
    if (def.has("merge")) def["merge"]["fps"] = mMaxFps;
    if (def.has("dispatch")) def["dispatch"]["fps"] = mMaxFps;
    return def;
}

arras4::client::SessionOptions
ArrasSettings::getSessionOptions()
{
    const char* v = std::getenv("HDMOONRAY_PRODUCTION");
    return arras4::client::SessionOptions().setProduction(v ? v : "");
}

void
ArrasSettings::setLocalMode(bool flag)
{
    if (flag != mLocalMode) {
        mLocalMode = flag;
        mReconnectRequired = true;
    }
}

void
ArrasSettings::setLocalReservedCores(int val)
{
    if (val != mLocalReservedCores) {
        mLocalReservedCores = val;
        if (mLocalMode) mReconnectRequired = true;
    }
}

void
ArrasSettings::setHostCount(int count)
{
    if (count != mHostCount) {
        mHostCount = count;
        if (!mLocalMode) mReconnectRequired = true;
    }
}

void
ArrasSettings::setMaxFps(float val)
{
    if (val != mMaxFps) {
        mMaxFps = val;
        mReconnectRequired = true;
    }
}

void
ArrasSettings::setExecMode(std::string val)
{
    if (val != mExecMode){
        if (val == "vectorized" || val == "auto" || val == "xpu" || val == "scalar") {
            mExecMode = val;
            mReconnectRequired = true;
        }
    }
}

void
ArrasSettings::reconnectTrigger(bool flag)
{
    if (flag != mReconnectTrigger) {
        mReconnectTrigger = flag;
        mReconnectRequired = true;
    }
}

void
ArrasSettings::setDenoiseMode(bool enable, bool albedoGuiding, bool normalGuiding)
{
    if (!enable) {
        mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::DISABLE;
    } else if (albedoGuiding) {
        if (normalGuiding) {
            mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE_W_ALBEDO_NORMAL;
        } else {
            mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE_W_ALBEDO;
        }
    } else if (normalGuiding) {
        mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE_W_NORMAL;
    } else {
        mDenoiseMode = mcrt_dataio::ClientReceiverFb::DenoiseMode::ENABLE;
    }
}

void
ArrasSettings::applySettings(const RenderSettings& settings)
{
    setLocalMode(settings.getArrasLocalMode());
    setLogLevel(settings.getArrasLogLevel());
    setHostCount(settings.getArrasHostCount());
    setLocalReservedCores(settings.getArrasLocalReservedCores());
    setMaxFps(settings.getArrasMaxFps());
    setExecMode(settings.getExecutionMode());
    reconnectTrigger(settings.getRestartToggle());
    setMaxConnectRetries(settings.getMaxConnectRetries());
    setDenoiseMode(settings.enableDenoise(),
                   settings.denoiseAlbedoGuiding(),
                   settings.denoiseNormalGuiding());
}

}
